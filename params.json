{
  "name": "Regular-express-and-parse-url",
  "tagline": "总结正则表达式和解析url",
  "body": "# 总结正则表达式和解析url\r\n## 解析url\r\n#### 将url的查询参数解析为字典对象？\r\n解决方案一般是拆字符串和用正则匹配。比价推荐的方法是正则匹配。因为url允许用户随意输入，如果用拆字符串的方法，有任何一个地方没考虑到容错，\r\n就会导致程序出错。而正则就没有这个问题。它只匹配出正确的配对。非法的全部过滤掉。不过这里把两种方式都写一下。\r\n\r\n**拆分字符串的方式**\r\n\r\n```\r\nfunction getUrlParms(){\r\n     var args=new Object(); \r\n     var query=location.search.substring(1);//获取查询串 \r\n     var pairs=query.split(\"&\");    // 以&分割\r\n     \r\n     for(var i=0;i<pairs.length;i++){ \r\n         var pos=pairs[i].indexOf('=');         //查找name=value \r\n         if(pos==-1) continue;                  //如果没有找到就跳过 \r\n         var argname=pairs[i].substring(0,pos); //提取name \r\n         var value=pairs[i].substring(pos+1);   //提取value \r\n         args[argname]=decodeURIComponent(value); //存为属性 \r\n     }\r\n     return args;\r\n}\r\n```\r\n\r\n**正则的方式**\r\n\r\n```\r\nfunction getQueryObject(url){\r\n  var urlStr=url==null?window.location.href:url;    //校验传进来的url。如果为null 则重新从window对象中取得\r\n  var search = urlStr.substring(urlStr.lastIndexOf(\"?\")+1);  //获取到问号后边的部分\r\n  var obj={};\r\n  var reg = /([^?&=]+)=([^?&=]*)/g;\r\n  search.replace(reg,function(rs,$1,$2){\r\n      var name = decodeURIComponent($1);\r\n      var val = decodeURIComponent($2);\r\n      obj[name]=String(val);\r\n      return rs;\r\n  });\r\n  return obj;\r\n}\r\n```\r\n明天解释正则~~\r\n----\r\n\r\n# 正则表达式 #\r\n## 概述 ##\r\nRegExp 构造函数可创建一个正则表达式对象，用特定的模式匹配文本。比如说你想验证一个字符串是不是手机号码？是不是应该判断是不是11位的数字呢？\r\n## 语法 ##\r\n\r\n```\t\r\n\r\n\tRegExp(pattern [, flags])\r\n\t\r\n\t/pattern/flags\r\n\r\n\r\n```\r\n## 参数 ##\r\n\r\npattern\r\n\r\n正则表达式文本\r\n\r\nflags\r\n\r\n该参数可以是下面几个值的任意组合：\r\n\r\ng\r\n\r\n全局匹配\r\n\r\ni\r\n\r\n忽略大小写\r\n\r\nm\r\n\r\n让开始和结束字符（^ 和 $）工作在多行模式（也就是，^ 和 $ 可以匹配字符串中每一行的开始和结束（行是由 \\n 或 \\r 分割的），而不只是整个输入字符串的最开始和最末尾处。\r\n\r\n### 创建 ###\r\n有两种方式可以创建正则对象：\r\n\r\n1.构造函数\r\n\r\n2.字面量\r\n\r\n要表示字符串，字面量形式不使用引号，而传递给构造函数的参数使用引号。下面表达式创建相同的正则表达式：\r\n\r\n```\r\n\t/ab+c/i;\r\n\r\n\tnew RegExp('ab+c', 'i');\r\n\r\n\tnew RegExp(/ab+c/, 'i');\r\n\r\n```\r\n\r\n## 正则表达式中的特殊字符 ##\r\n正则表达式中的特殊字符包括：字符类别（Character Classes）、字符集合（Character Sets）、边界（Boundaries）、分组（grouping）、反向引用（back references）、数量词（Quantifiers）。\r\n\r\n### 字符类别 ###\r\n**字符：.**\r\n\r\n含义：（点号，小数点）匹配任意单个字符，但是换行符除外，包括：\\n \\r \\u2028 或 \\u2029。\r\n\r\n需要注意的是，m 多行（multiline）标志不会改变点号的表现。因此为了匹配多行中的字符集，可使用[^] （当然你不是打算用在旧版本 IE 中），它将会匹配任意字符，包括换行符。\r\n\r\n例如，/.y/ 匹配 \"yes make my day\" 中的 \"my\" 和 \"ay\"，但是不匹配 \"yes\"。\r\n\r\n**字符：\\d**\r\n\r\n含义：匹配基本拉丁字母表（basic Latin alphabet）中的一个数字字符。等价于[0-9]。\r\n\r\n例如，/\\d/ 或 /[0-9]/ 匹配 \"B2 is the suite number.\" 中的 '2'。 \r\n\r\n\r\n**字符：\\D**\r\n\r\n含义：匹配任意一个不是基本拉丁字母表中数字的字符。等价于[^0-9]。\r\n\r\n例如，/\\D/ 或 /[^0-9]/ 匹配 \"B2 is the suite number.\" 中的 'B'。\r\n\r\n\r\n**字符：\\w**\r\n\r\n含义：匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。\r\n\r\n例如，/\\w/ 匹配 \"apple\" 中的 'a'，\"$5.28\" 中的 '5' 和 \"3D\" 中的 '3'。\r\n\r\n**字符：\\W**\r\n\r\n匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9_]。\r\n\r\n例如，/\\W/ 或 /[^A-Za-z0-9_]/ 匹配 \"50%\" 中的 '%'。\r\n\r\n**字符：\\S**\r\n\r\n匹配一个非空白符。等价于 [^ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​ \\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​\\u202f\\u205f​\\u3000]。\r\n\r\n例如，/\\S\\w*/ 匹配 \"foo bar\" 中的 'foo'。\r\n\r\n**字符：\\t**\r\n\r\n匹配一个水平制表符（tab）\r\n\r\n**字符：\\r**\r\n\r\n匹配一个回车符（carriage return）\r\n\r\n**字符：\\n**\r\n\r\n匹配一个换行符（linefeed）\r\n\r\n**字符：\\v**\r\n\r\n匹配一个垂直制表符（vertical tab）\r\n\r\n**字符：\\f**\r\n\r\n匹配一个换页符（form-feed）\r\n\r\n**字符：\\f**\r\n\r\n匹配一个换页符（form-feed）\r\n\r\n**字符：[\\b]**\r\n\r\n匹配一个退格符（backspace）（不要与 \\b 混淆）\r\n\r\n\r\n**字符：[\\b]**\r\n\r\n匹配一个退格符（backspace）（不要与 \\b 混淆）\r\n\r\n**字符：\\xhh**\r\n\r\n匹配编码为 hh （两个十六进制数字）的字符。\r\n\r\n**字符：\\uhhhh**\r\n\r\n匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。\r\n\r\n**字符：\\**\r\n\r\n对于那些通常被认为字面意义的字符来说，表示下一个字符具有特殊用处，并且不会被按照字面意义解释。\r\n\r\n例如 /b/ 匹配字符 'b'。在 b 前面加上一个反斜杠，即使用 /\\b/，则该字符变得特殊，以为这匹配一个单词边界。\r\n\r\n或\r\n\r\n对于那些通常特殊对待的字符，表示下一个字符不具有特殊用途，会被按照字面意义解释。\r\n\r\n例如，* 是一个特殊字符，表示匹配某个字符 0 或多次，如 /a*/ 意味着 0 或多个 \"a\"。 为了匹配字面意义上的 * ，在它前面加上一个反斜杠，例如，/a\\*/匹配 'a*'。\r\n\r\n### 字符集合 ###\r\n\r\n**字符集合：[xyz]**\r\n\r\n一个字符集合，也叫字符组。匹配集合中的任意一个字符。你可以使用连字符'-'指定一个范围。\r\n\r\n例如，[abcd] 等价于 [a-d]，匹配\"brisket\"中的'b'和\"chop\"中的'c'。\r\n\r\n**字符集合：[^xyz]**\r\n\r\n一个反义或补充字符集，也叫反义字符组。也就是说，它匹配任意不在括号内的字符。你也可以通过使用连字符 '-' 指定一个范围内的字符。\r\n\r\n例如，[^abc] 等价于 [^a-c]。 第一个匹配的是 \"bacon\" 中的'o' 和 \"chop\" 中的 'h'。\r\n\r\n### 边界 ###\r\n\r\n**边界：^**\r\n\r\n匹配输入/字符串的开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。\r\n\r\n例如，/^A/ 不匹配 \"an A\" 中的 \"A\"，但匹配 \"An A\" 中的 \"A\"。\r\n\r\n**边界：$**\r\n\r\n匹配输入/字符串的结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。\r\n\r\n例如，/t$/ 不匹配 \"eater\" 中的 \"t\"，但匹配 \"eat\" 中的 \"t\"。\r\n\r\n**边界：\\b**\r\n\r\n匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。 （不要和 [\\b] 混淆）\r\n\r\n例如，/\\bno/ 匹配 \"at noon\" 中的 \"no\"，/ly\\b/ 匹配 \"possibly yesterday.\" 中的 \"ly\"。\r\n\r\n**边界：\\B**\r\n\r\n匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。\r\n\r\n例如，/\\Bon/ 匹配 \"at noon\" 中的 \"on\"，/ye\\B/ 匹配 \"possibly yesterday.\" 中的 \"ye\"。\r\n\r\n### 分组 ###\r\n\r\n重复单字符我们可以使用限定符，如果重复字符串，用什么呢？ 对！用小括号，小括号里包裹指定字表达式（子串），这就是分组。之后就可以限定这个子表示式的重复次数了。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}